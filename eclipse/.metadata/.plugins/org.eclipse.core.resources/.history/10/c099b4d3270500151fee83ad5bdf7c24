package net.minecraft.src;

public abstract class BlockOnWall extends Block {
	
	protected float depth = 0.5f / 16f;
	protected float width = 1f;
	protected float widthMin = (1 - width) * 0.5f;
	protected float widthMax = (1 + width) * 0.5f;

	public BlockOnWall(int i, Material material) {
		super(i, material);
	}

	public BlockOnWall(int i, int j, Material material) {
		super(i, j, material);
	}
	
	@Override
	public AxisAlignedBB getCollisionBoundingBoxFromPool(World world, int i, int j, int k) {
		return null;
	}
	
	@Override
	public void setBlockBoundsBasedOnState(IBlockAccess iblockaccess, int i, int j, int k) {
		BlockFace face = BlockOnWall.getAttachedSide(iblockaccess.getBlockMetadata(i, j, k));
		switch(face) {
		case NORTH:
			setBlockBounds(renderingOverlay ? 1 - depth - 1f/64f : 1 - depth, widthMin, widthMin, renderingOverlay ? 1 - depth - 1f/64f : 1, widthMax, widthMax);
			break;
		case SOUTH:
			setBlockBounds(renderingOverlay ? depth + 1f / 64f : 0, widthMin, widthMin, renderingOverlay ? depth + 1f / 64f : depth, widthMax, widthMax);
			break;
		case EAST:
			setBlockBounds(widthMin, widthMin, renderingOverlay ? 1 - depth - 1f / 64f : 1 - depth, widthMax, widthMax, renderingOverlay ? 1 - depth - 1f / 64f : 1);
			break;
		case WEST:
		default:
			setBlockBounds(widthMin, widthMin, renderingOverlay ? depth + 1f / 64f : 0, widthMax, widthMax, renderingOverlay ? depth + 1f / 64f : depth);
			break;
		}
	}

	public static BlockFace getAttachedSide(int data) {
		switch(data & 7) {
		case 1:
			return BlockFace.NORTH;
		case 2:
			return BlockFace.SOUTH;
		case 3:
			return BlockFace.EAST;
		case 4:
			return BlockFace.WEST;
		case 5:
			return BlockFace.TOP;
		case 6:
			return BlockFace.DOWN;
		}
		return BlockFace.NORTH; // NPE workaround
	}
	
	public static int getData(BlockFace side) {
		switch(side) {
		case NORTH:
			return 1;
		case SOUTH:
			return 2;
		case EAST:
			return 3;
		case WEST:
			return 4;
		case TOP:
			return 5;
		case DOWN:
			return 6;
		default:
			return 1;
		}
	}
}
